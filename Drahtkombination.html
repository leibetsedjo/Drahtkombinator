<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drahtkombinator</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      padding: 20px;
      background: #f4f4f8;
      color: #333;
    }
    h2, h3, h4 {
      color: #2c3e50;
    }
    input, button {
      margin: 4px;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-size: 1em;
    }
    input:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 3px rgba(52, 152, 219, 0.5);
    }
    button {
      background-color: #3498db;
      color: white;
      cursor: pointer;
      border: none;
    }
    button:hover {
      background-color: #2980b9;
    }
    .stock-item {
      margin-bottom: 6px;
    }
    .warning {
      color: red;
      font-weight: bold;
      margin-top: 10px;
    }
    .info {
      font-size: 0.9em;
      color: #555;
      margin: 10px 0;
    }
    .combination {
      background: white;
      border-radius: 10px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      padding: 12px;
      margin: 10px 0;
    }
  </style>
</head>
<body>

<div id="root"></div>

<script>
const e = React.createElement;

function calculateCrossSection(d) {
  return Math.PI * d * d / 4;
}

function combine(arr, length) {
  if (length === 0) return [[]];
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const first = arr[i];
    const rest = arr.slice(i);
    const combos = combine(rest, length - 1);
    combos.forEach(c => result.push([first, ...c]));
  }
  return result;
}

function App() {
  const [entries, setEntries] = React.useState([
    { d: '', c: '' },
    { d: '', c: '' },
    { d: '', c: '' },
    { d: '', c: '' }
  ]);

  const [maxDev, setMaxDev] = React.useState('10');
  const [minOffset, setMinOffset] = React.useState('0.2');
  const [maxOffset, setMaxOffset] = React.useState('0.2');
  const [stock, setStock] = React.useState([
    { d: 0.20, a: true }, { d: 0.25, a: true }, { d: 0.30, a: true },
    { d: 0.35, a: true }, { d: 0.40, a: true }, { d: 0.43, a: true },
    { d: 0.45, a: true }, { d: 0.50, a: true }, { d: 0.55, a: true },
    { d: 0.60, a: true }, { d: 0.65, a: true }, { d: 0.67, a: true },
    { d: 0.70, a: true }, { d: 0.75, a: true }, { d: 0.80, a: true },
    { d: 0.85, a: true }, { d: 0.90, a: true }, { d: 1.06, a: true },
    { d: 1.12, a: true }, { d: 1.18, a: true }, { d: 1.20, a: true },
    { d: 1.25, a: true }
  ]);

  const [results, setResults] = React.useState([]);
  const [total, setTotal] = React.useState(0);
  const [showStock, setShowStock] = React.useState(false);
  const [newDia, setNewDia] = React.useState('');
  const [message, setMessage] = React.useState('');

  function updateEntry(i, field, val) {
    const ne = entries.slice();
    ne[i][field] = val.replace(',', '.');
    setEntries(ne);
  }

  function toggle(i) {
    const ns = stock.slice();
    ns[i].a = !ns[i].a;
    setStock(ns);
  }

  function deleteStock(i) {
    const ns = stock.slice();
    ns.splice(i, 1);
    setStock(ns);
  }

  function addStock() {
    const dia = parseFloat(newDia.replace(',', '.'));
    if (!isNaN(dia)) {
      setStock([...stock, { d: dia, a: true }]);
      setNewDia('');
    }
  }

  function calc() {
    let tot = 0;
    let minOriginal = Infinity;
    let maxOriginal = -Infinity;
    let totalCount = 0;
    let missingDiameters = [];

    entries.forEach(en => {
      const d = parseFloat(en.d);
      const c = parseInt(en.c);
      if (!isNaN(d) && !isNaN(c)) {
        tot += calculateCrossSection(d) * c;
        totalCount += c;
        if (d < minOriginal) minOriginal = d;
        if (d > maxOriginal) maxOriginal = d;

        const existsInStock = stock.some(s => s.a && s.d === d);
        if (!existsInStock) missingDiameters.push(d);
      }
    });

    setTotal(tot);
    if (missingDiameters.length > 0) {
      setMessage('Hinweis: Folgende Durchmesser sind nicht im Lager vorhanden und werden durch passende ersetzt: ' + missingDiameters.join(', ') + ' mm');
    } else {
      setMessage('');
    }

    const maxDevPercent = parseFloat(maxDev.replace(',', '.'));
    const minTol = minOriginal - parseFloat(minOffset.replace(',', '.'));
    const maxTol = maxOriginal + parseFloat(maxOffset.replace(',', '.'));

    const activeStock = stock.filter(s => s.a);
    const validStock = activeStock.filter(s => s.d >= minTol && s.d <= maxTol);

    const allCombos = [];
    let comboCount = 0;
    outer: for (let len = 1; len <= totalCount; len++) {
      const combos = combine(validStock, len);
      for (let c of combos) {
        comboCount++;
        if (comboCount > 1000) break outer;

        const grp = {};
        c.forEach(x => grp[x.d] = (grp[x.d] || 0) + 1);
        const cross = c.reduce((sum, x) => sum + calculateCrossSection(x.d), 0);
        const dev = cross - tot;
        const devAbsPercent = tot ? Math.abs(dev / tot) * 100 : 0;
        allCombos.push({
          grouped: grp,
          cross,
          dev,
          devPercent: devAbsPercent,
          types: Object.keys(grp).length
        });
      }
    }

    allCombos.sort((a, b) => {
      if (a.devPercent !== b.devPercent) return a.devPercent - b.devPercent;
      return a.types - b.types;
    });

    const filtered = allCombos.filter(c => c.devPercent <= maxDevPercent);

    if (filtered.length === 0 && allCombos.length > 0) {
      setMessage('Keine passende Kombination innerhalb der Abweichung gefunden. Hier die besten Alternativen:');
      setResults(allCombos.slice(0, 5));
    } else if (filtered.length === 0 && allCombos.length === 0) {
      setMessage('⚠️ Es konnte keine einzige Kombination aus dem aktuellen Lager gebildet werden.');
      setResults([]);
    } else {
      setResults(filtered.slice(0, 5));
    }
  }

  return e('div', null,
    e('h2', null, 'Drahtkombinator'),
    entries.map((en, i) =>
      e('div', { key: i },
        e('input', {
          placeholder: 'Durchmesser mm',
          value: en.d,
          onChange: e => updateEntry(i, 'd', e.target.value)
        }),
        e('input', {
          placeholder: 'Anzahl',
          value: en.c,
          onChange: e => updateEntry(i, 'c', e.target.value)
        })
      )
    ),
    e('div', { style: { marginTop: '12px' } },
      e('label', { htmlFor: 'maxDev' }, 'Max. Abweichung [%]:'),
      e('input', {
        id: 'maxDev',
        type: 'number',
        style: { width: '60px' },
        value: maxDev,
        onChange: e => setMaxDev(e.target.value)
      }),
      e('input', {
        type: 'number',
        placeholder: '- Offset (z.B. 0.2)',
        value: minOffset,
        onChange: e => setMinOffset(e.target.value),
        style: { width: '80px', marginLeft: '10px' }
      }),
      e('input', {
        type: 'number',
        placeholder: '+ Offset (z.B. 0.2)',
        value: maxOffset,
        onChange: e => setMaxOffset(e.target.value),
        style: { width: '80px', marginLeft: '10px' }
      })
    ),
    e('div', { className: 'info' },
      'Kombinationen mit max. ±' + maxDev + '% Abweichung, nur Drähte zwischen (min-' + minOffset + ') mm und (max+' + maxOffset + ') mm werden verwendet.'
    ),
    e('div', null,
      e('button', { onClick: calc }, 'Berechnen'),
      e('button', { onClick: () => setShowStock(s => !s) }, 'Lager anzeigen/verstecken'),
      e('button', {
        onClick: () => {
          setEntries([
            { d: '', c: '' },
            { d: '', c: '' },
            { d: '', c: '' },
            { d: '', c: '' }
          ]);
          setResults([]);
          setMessage('');
          setTotal(0);
          setMaxDev('10');
          setMinOffset('0.2');
          setMaxOffset('0.2');
        },
        style: { marginLeft: '10px', backgroundColor: '#e67e22' }
      }, 'Neue Berechnung starten')
    ),
    showStock && e('div', null,
      e('h3', null, 'Lagerbestand:'),
      stock.map((s, i) =>
        e('div', { key: i, className: 'stock-item' },
          e('span', null, s.d.toFixed(2) + ' mm '),
          e('input', {
            type: 'checkbox',
            checked: s.a,
            onChange: () => toggle(i)
          }),
          e('button', { onClick: () => deleteStock(i) }, 'Löschen')
        )
      ),
      e('div', null,
        e('input', {
          placeholder: 'z. B. 0,18',
          value: newDia,
          onChange: e => setNewDia(e.target.value)
        }),
        e('button', { onClick: addStock }, 'Hinzufügen')
      )
    ),
    total > 0 && e('div', null,
      e('p', null, 'Original Gesamtquerschnitt: ' + total.toFixed(4) + ' mm²'),
      message && e('p', { className: 'warning' }, message),
      results.map((r, idx) =>
        e('div', { key: idx, className: 'combination' },
          e('h4', null, 'Kombination ' + (idx + 1)),
          e('ul', null,
            Object.entries(r.grouped).map(([dia, count]) =>
              e('li', null, count + ' x ' + dia + ' mm')
            )
          ),
          e('p', null, 'Gesamtquerschnitt: ' + r.cross.toFixed(4) + ' mm²'),
          e('p', null, 'Abweichung: ' +
            (r.dev >= 0 ? '+' : '') + r.dev.toFixed(4) + ' mm² (' +
            (r.devPercent >= 0 ? '+' : '') + r.devPercent.toFixed(2) + '%)')
        )
      )
    )
  );
}

ReactDOM.render(e(App), document.getElementById('root'));
</script>

</body>
</html>
