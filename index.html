<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drahtkombinator</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      padding: 20px;
      background: #f4f4f8;
      color: #333;
    }
    h2, h3, h4 {
      color: #2c3e50;
    }
    .entry-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    input, button {
      margin: 4px;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-size: 1em;
    }
    input {
      width: 120px;
      max-width: 45%;
    }
    button {
      background-color: #3498db;
      color: white;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background-color: #2980b9;
    }
    .stock-item {
      margin-bottom: 4px;
    }
    .warning {
      color: red;
      font-weight: bold;
      margin-top: 10px;
    }
    .info {
      font-size: 0.9em;
      color: #555;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<div id="root"></div>
<script>
const e = React.createElement;

function calculateCrossSection(d) {
  return Math.PI * d * d / 4;
}

function combine(arr, length) {
  if (length === 0) return [[]];
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const first = arr[i];
    const rest = arr.slice(i);
    const combos = combine(rest, length - 1);
    combos.forEach(c => result.push([first, ...c]));
  }
  return result;
}

function App() {
  const [entries, setEntries] = React.useState([
    { d: '', c: '' },
    { d: '', c: '' },
    { d: '', c: '' },
    { d: '', c: '' }
  ]);

  const [maxDev, setMaxDev] = React.useState('10');
  const [minOffset, setMinOffset] = React.useState('0.2');
  const [maxOffset, setMaxOffset] = React.useState('0.2');
  const [stock, setStock] = React.useState([
    { d: 0.20, a: true }, { d: 0.25, a: true }, { d: 0.30, a: true },
    { d: 0.35, a: true }, { d: 0.40, a: true }, { d: 0.43, a: true },
    { d: 0.45, a: true }, { d: 0.50, a: true }, { d: 0.55, a: true },
    { d: 0.60, a: true }, { d: 0.65, a: true }, { d: 0.67, a: true },
    { d: 0.70, a: true }, { d: 0.75, a: true }, { d: 0.80, a: true },
    { d: 0.85, a: true }, { d: 0.90, a: true }, { d: 1.06, a: true },
    { d: 1.12, a: true }, { d: 1.18, a: true }, { d: 1.20, a: true },
    { d: 1.25, a: true }
  ]);

  const [results, setResults] = React.useState([]);
  const [total, setTotal] = React.useState(0);
  const [showStock, setShowStock] = React.useState(false);
  const [newDia, setNewDia] = React.useState('');
  const [message, setMessage] = React.useState('');

  function updateEntry(i, field, val) {
    const ne = entries.slice();
    ne[i][field] = val.replace(',', '.');
    setEntries(ne);
  }

  function toggle(i) {
    const ns = stock.slice();
    ns[i].a = !ns[i].a;
    setStock(ns);
  }

  function deleteStock(i) {
    const ns = stock.slice();
    ns.splice(i, 1);
    setStock(ns);
  }

  function addStock() {
    const dia = parseFloat(newDia.replace(',', '.'));
    if (!isNaN(dia)) {
      setStock([...stock, { d: dia, a: true }]);
      setNewDia('');
    }
  }

  function calc() {
    let tot = 0;
    let minOriginal = Infinity;
    let maxOriginal = -Infinity;
    let totalCount = 0;
    let missingDiameters = [];

    entries.forEach(en => {
      const d = parseFloat(en.d);
      const c = parseInt(en.c);
      if (!isNaN(d) && !isNaN(c)) {
        tot += calculateCrossSection(d) * c;
        totalCount += c;
        if (d < minOriginal) minOriginal = d;
        if (d > maxOriginal) maxOriginal = d;

        const existsInStock = stock.some(s => s.a && s.d === d);
        if (!existsInStock) missingDiameters.push(d);
      }
    });

    setTotal(tot);
    if (missingDiameters.length > 0) {
      setMessage('Hinweis: Folgende Durchmesser sind nicht im Lager vorhanden und werden durch passende ersetzt: ' + missingDiameters.join(', ') + ' mm');
    } else {
      setMessage('');
    }

    const maxDevPercent = parseFloat(maxDev.replace(',', '.'));
    const minTol = parseFloat(minOffset.replace(',', '.'));
    const maxTol = parseFloat(maxOffset.replace(',', '.'));
    if (isNaN(maxDevPercent) || isNaN(minTol) || isNaN(maxTol)) return;

    const minAllowed = minOriginal - minTol;
    const maxAllowed = maxOriginal + maxTol;
    const activeStock = stock.filter(s => s.a && s.d >= minAllowed && s.d <= maxAllowed);

    const allCombos = [];
    let comboCount = 0;
    outer: for (let len = 1; len <= totalCount; len++) {
      const combos = combine(activeStock, len);
      for (let c of combos) {
        comboCount++;
        if (comboCount > 1000) break outer;
        const grp = {};
        c.forEach(x => grp[x.d] = (grp[x.d] || 0) + 1);
        const cross = c.reduce((sum, x) => sum + calculateCrossSection(x.d), 0);
        const dev = cross - tot;
        const devAbsPercent = tot ? Math.abs(dev / tot) * 100 : 0;
        allCombos.push({
          grouped: grp,
          cross,
          dev,
          devPercent: devAbsPercent,
          types: Object.keys(grp).length
        });
      }
    }

    allCombos.sort((a, b) => {
      if (a.devPercent !== b.devPercent) return a.devPercent - b.devPercent;
      return a.types - b.types;
    });

    const filtered = allCombos.filter(c => c.devPercent <= maxDevPercent);

    if (filtered.length === 0 && allCombos.length > 0) {
      setMessage('Keine passende Kombination innerhalb der Abweichung gefunden. Hier die besten Alternativen:');
      setResults(allCombos.slice(0, 5));
    } else if (filtered.length === 0 && allCombos.length === 0) {
      setMessage('⚠️ Es konnte keine einzige Kombination aus dem aktuellen Lager gebildet werden.');
      setResults([]);
    } else {
      const pos = filtered.find(c => c.dev >= 0);
      const neg = filtered.find(c => c.dev <= 0);
      const rest = filtered.filter(c => c !== pos && c !== neg);
      const resultList = [];
      if (pos) resultList.push(pos);
      if (neg && neg !== pos) resultList.push(neg);
      resultList.push(...rest.slice(0, 3));
      setMessage(missingDiameters.length ? message : '');
      setResults(resultList);
    }
  }

  return e('div', null,
    e('h2', null, 'Drahtkombinator'),
    entries.map((en, i) =>
      e('div', { className: 'entry-row', key: i },
        e('input', {
          placeholder: 'Durchmesser mm',
          value: en.d,
          onChange: e => updateEntry(i, 'd', e.target.value)
        }),
        e('input', {
          placeholder: 'Anzahl',
          value: en.c,
          onChange: e => updateEntry(i, 'c', e.target.value)
        })
      )
    ),
    e('div', null,
      e('label', null, 'Max. Abweichung [%]: '),
      e('input', {
        type: 'number',
        value: maxDev,
        onChange: e => setMaxDev(e.target.value),
        style: { width: '60px' }
      }),
      e('label', { style: { marginLeft: '10px' } }, '− Toleranz:'),
      e('input', {
        type: 'number',
        value: minOffset,
        onChange: e => setMinOffset(e.target.value),
        style: { width: '60px' }
      }),
      e('label', { style: { marginLeft: '10px' } }, '+ Toleranz:'),
      e('input', {
        type: 'number',
        value: maxOffset,
        onChange: e => setMaxOffset(e.target.value),
        style: { width: '60px' }
      })
    ),
    e('div', { className: 'info' },
      'Nur Kombinationen mit max. ±' + maxDev + '% Abweichung werden angezeigt.'
    ),
    e('div', null,
      e('button', { onClick: calc }, 'Berechnen'),
      e('button', { onClick: () => setShowStock(s => !s) }, 'Lager anzeigen/verstecken'),
      e('button', {
        onClick: () => {
          setEntries([
            { d: '', c: '' },
            { d: '', c: '' },
            { d: '', c: '' },
            { d: '', c: '' }
          ]);
          setResults([]);
          setMessage('');
          setTotal(0);
          setMaxDev('10');
          setMinOffset('0.2');
          setMaxOffset('0.2');
        },
        style: { marginLeft: '10px', backgroundColor: '#e67e22' }
      }, 'Neue Berechnung starten'),
      e('button', {
        onClick: () => {
          alert('Tipp: Du kannst beim Speichern selbst den Namen eingeben, z. B.: "Drahtkombination.pdf"');
          window.print();
        },
        style: { marginLeft: '10px', backgroundColor: '#16a085' }
      }, 'Als PDF speichern'),
      e('input', {
        placeholder: 'Dateiname für PDF (optional)',
        id: 'pdfName',
        style: { marginLeft: '10px', padding: '6px', width: '200px' }
      }),
      e('button', {
        onClick: () => {
          alert('Tipp: Du kannst beim Speichern selbst den Namen eingeben, z. B.: "Drahtkombination.pdf"');
          window.print();
        },
        style: { marginLeft: '10px', backgroundColor: '#16a085' }
      }, 'Als PDF speichern')
    ),
    showStock && e('div', null,
      e('h3', null, 'Lagerbestand:'),
      stock.map((s, i) =>
        e('div', { key: i, className: 'stock-item' },
          e('span', null, s.d.toFixed(2) + ' mm '),
          e('input', {
            type: 'checkbox',
            checked: s.a,
            onChange: () => toggle(i)
          }),
          e('button', { onClick: () => deleteStock(i) }, 'Löschen')
        )
      ),
      e('div', null,
        e('input', {
          placeholder: 'z. B. 0,18',
          value: newDia,
          onChange: e => setNewDia(e.target.value)
        }),
        e('button', { onClick: addStock }, 'Hinzufügen')
      )
    ),
    total > 0 && e('div', null,
      e('p', null, 'Original Gesamt: ' + total.toFixed(4) + ' mm²'),
      message && e('p', { className: 'warning' }, message),
      results.map((r, idx) => {
        let bgColor = '#ffffff';
        if (r.dev > 0) bgColor = '#d4edda'; // grün
        else if (r.dev < 0) bgColor = '#fff3cd'; // orange
        if (r.devPercent >= parseFloat(maxDev)) bgColor = '#f8d7da'; // rot

        return e('div', {
          key: idx,
          style: {
            border: '1px solid #ccc',
            margin: '6px',
            padding: '6px',
            borderRadius: '8px',
            backgroundColor: bgColor
          }
        },
          e('h4', null,
            idx === 0 && r.dev >= 0 ? 'Kombination 1 (Abweichung positiv)' :
            idx === 0 && r.dev < 0  ? 'Kombination 1 (Abweichung negativ)' :
            idx === 1 && r.dev >= 0 ? 'Kombination 2 (Abweichung positiv)' :
            idx === 1 && r.dev < 0  ? 'Kombination 2 (Abweichung negativ)' :
            'Kombination ' + (idx + 1)
          ),
          e('ul', null,
            Object.entries(r.grouped).map(([dia, count]) =>
              e('li', null, count + ' x ' + dia + ' mm')
            )
          ),
          e('p', null, 'Gesamt: ' + r.cross.toFixed(4) + ' mm²'),
          e('p', null, 'Abweichung: ' +
            (r.dev >= 0 ? '+' : '') + r.dev.toFixed(4) + ' mm² (' +
            (r.devPercent >= 0 ? '+' : '') + r.devPercent.toFixed(2) + '%)')
        );
      })
    )
  );
}

ReactDOM.render(e(App), document.getElementById('root'));
</script>
</body>
</html>
